package translate

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/printer"
	"go/token"
	"io"
	"io/fs"
	"log"
	"os"
	"path"
	"path/filepath"
	"sync"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/dst/decorator/resolver"
)

const header = "// Code generated by gosim. DO NOT EDIT.\n"

type jankyGuessResolver struct {
	known map[string]string
}

func (r jankyGuessResolver) ResolvePackage(importPath string) (string, error) {
	if known, ok := r.known[importPath]; ok {
		return known, nil
	}
	log.Fatalf("unknown package %q", importPath)
	panic(importPath)
}

func newJankyGuessResolver(known map[string]string) resolver.RestorerResolver {
	return &jankyGuessResolver{
		known: known,
	}
}

func dstFileToAstFile(f *dst.File, path string, known map[string]string) (*ast.File, *token.FileSet, error) {
	res := decorator.NewRestorer()
	res.Resolver = newJankyGuessResolver(known)
	res.Path = path

	var buf bytes.Buffer
	buf.WriteString(header)

	// lifted from res.RestoreFile but modified so we can have the alias
	restorer := res.FileRestorer()
	restorer.Alias["testing"] = "testing_original"
	af, err := restorer.RestoreFile(f)
	if err != nil {
		return nil, nil, err
	}

	seen := make(map[string]struct{})

	for _, decl := range af.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		if genDecl.Tok != token.IMPORT {
			continue
		}

		var filtered []ast.Spec
		for _, spec := range genDecl.Specs {
			importSpec, _ := spec.(*ast.ImportSpec)
			if importSpec.Name != nil {
				filtered = append(filtered, importSpec)
				continue
			}
			if _, ok := seen[importSpec.Path.Value]; ok {
				continue
			}
			seen[importSpec.Path.Value] = struct{}{}
			filtered = append(filtered, importSpec)
		}

		genDecl.Specs = filtered
	}

	return af, res.Fset, nil
}

func dstFileToBytes(f *dst.File, known map[string]string, path string) ([]byte, error) {
	af, fset, err := dstFileToAstFile(f, path, known)
	if err != nil {
		return nil, err
	}

	var buf bytes.Buffer
	buf.WriteString(header)
	if err := formatNode(&buf, fset, af); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func formatNode(w io.Writer, fset *token.FileSet, af any) error {
	if err := format.Node(w, fset, af); err != nil {
		var buf2 bytes.Buffer
		if err := printer.Fprint(&buf2, fset, af); err != nil {
			return fmt.Errorf("error formatting\ninner: %v\norig: %w", err, err)
		}
		return fmt.Errorf("error formatting\n%s\norig: %w", buf2.String(), err)
	}
	return nil
}

type outputWriter struct {
	mu      sync.Mutex
	desired map[string][]byte
}

func newOutputWriter() *outputWriter {
	return &outputWriter{
		desired: make(map[string][]byte),
	}
}

func (w *outputWriter) stage(path string, contents []byte) error {
	w.mu.Lock()
	defer w.mu.Unlock()

	w.desired[path] = contents
	return nil
}

func (w *outputWriter) extract() map[string][]byte {
	return w.desired
}

func (w *outputWriter) merge(m map[string][]byte) error {
	for path, contents := range m {
		if err := w.stage(path, contents); err != nil {
			return err
		}
	}
	return nil
}

func maybeDeleteGeneratedFile(path string) error {
	contents, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	if !bytes.HasPrefix(contents, []byte(header)) {
		return nil
	}
	if *dryrun {
		log.Println("deleting", path)
	} else {
		if err := os.Remove(path); err != nil {
			return err
		}
	}
	return nil
}

var dryrun = flag.Bool("dryrun", false, "dryrun")

func (w *outputWriter) maybeDeleteGeneratedFiles(rootOutputDir string) error {
	desiredFinal := make(map[string]struct{})
	for p := range w.desired {
		desiredFinal[filepath.Join(rootOutputDir, p)] = struct{}{}
	}

	touchedDirs := make(map[string]struct{})
	for path := range desiredFinal {
		// mark this package
		touchedDirs[filepath.Dir(path)] = struct{}{}
	}

	var dirs []string
	if err := filepath.WalkDir(rootOutputDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			if path == rootOutputDir && errors.Is(err, os.ErrNotExist) {
				return nil
			}
			return err
		}

		if d.IsDir() {
			dirs = append(dirs, path)
			return nil
		}

		if _, ok := desiredFinal[path]; !ok {
			if _, ok := touchedDirs[filepath.Dir(path)]; !ok {
				// skip directories that we are not writing to
				return nil
			}

			if err := maybeDeleteGeneratedFile(path); err != nil {
				return err
			}
			return nil
		}

		return nil
	}); err != nil {
		return err
	}

	if !*dryrun {
		for i := len(dirs) - 1; i >= 0; i-- {
			dir := dirs[i]
			contents, err := os.ReadDir(dir)
			if err != nil {
				return err
			}
			if len(contents) == 0 {
				if err := os.Remove(dir); err != nil {
					return err
				}
			}
		}
	}

	return nil
}

func (w *outputWriter) writeFiles(rootDir string) error {
	for p, desired := range w.desired {
		finalP := filepath.Join(rootDir, p)

		existing, err := os.ReadFile(finalP)
		if err != nil {
			if !errors.Is(err, os.ErrNotExist) {
				return err
			}
		}
		if err == nil {
			if bytes.Equal(desired, existing) {
				continue
			}
		}

		if *dryrun {
			log.Println("writing", finalP)
		} else {
			if err := os.MkdirAll(path.Dir(finalP), 0o755); err != nil {
				return err
			}
			if err := os.WriteFile(finalP, desired, 0o644); err != nil {
				return err
			}
		}
	}

	return nil
}
